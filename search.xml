<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PAT乙级]]></title>
    <url>%2F2019%2F10%2F07%2FPAT%E4%B9%99%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[PAT乙级学习笔记编号 标题 题解 分类1001 害死人不偿命的(3n+1)猜想 C++ 简单模拟1002 写出这个数 C++ 字符串处理1003 我要通过！ C++ 数学1004 成绩排名 C++ 查找元素1005 继续(3n+1)猜想 C++ 散列1006 换个格式输出整数 C++ 字符串处理1007 素数对猜想 C++ 素数1008 数组元素循环右移问题 C++ 简单模拟1009 说反话 C++、Java、python 字符串处理1010 一元多项式求导 C++ 简单模拟1011 A+B和C C++ 简单模拟1012 数字分类 C++ 简单模拟1013 数素数 C++ 素数1014 福尔摩斯的约会 C++ 字符串处理1015 德才论 C++ 排序1016 部分A+B C++ 简单模拟1017 A除以B C++ 大整数运算1018 锤子剪刀布 C++ 简单模拟1019 数字黑洞 C++ 数学1020 月饼 C++ 贪心1021 个位数统计 C++ 字符串处理1022 D进制的A+B C++ 进制转换1023 组个最小数 C++ 贪心1024 科学计数法 C++ 字符串处理1025 反转链表 C++ 链表1026 程序运行时间 C++ 简单模拟1027 打印沙漏 C++ 字符串处理1028 人口普查 C++ 查找元素1029 旧键盘 C++ 散列1030 完美数列 C++ 二分查找、two pointers1031 查验身份证 C++ 字符串处理1032 挖掘机技术哪家强 C++ 查找元素1033 旧键盘打字 C++ 散列1034 有理数四则运算 C++ 分数1035 插入与归并 C++ 暂无1036 跟奥巴马一起编程 C++ 图形输出1037 在霍格沃茨找零钱 C++ 进制转换1038 统计同成绩学生 C++ 散列1039 到底买不买 C++ 散列1040 有几个PAT C++ 动态规划1041 考试座位号 C++ 查找元素1042 字符统计 C++ 散列1043 输出PATest C++ 散列1044 火星数字 C++ 进制转换+字符串处理1045 快速排序 C++ 动态规划1046 划拳 C++ 简单模拟1047 编程团体赛 C++ 散列1048 数字加密 C++ 字符串处理1049 数列的片段和 C++ 数学1050 螺旋矩阵 C++ 中级模拟1051 复数乘法 C++ 数学1052 卖个萌 C++ 字符串处理1053 住房空置率 C++ 简单模拟1054 求平均值 C++ 字符串处理1055 集体照 C++ 排序+中级模拟1056 组合数的和 C++ 简单模拟1057 数零壹 C++ 进制转换1058 选择题 C++ 中级模拟+常用stl1059 C语言竞赛 C++ 散列1060 爱丁顿数 C++ 中级模拟1061 判断题 C++ 简单模拟1062 最简分数 C++ 分数1063 计算谱半径 C++ 简单模拟1064 朋友数 C++ 常用stl1065 单身狗 C++ 散列+常用stl1066 图像过滤 C++ 简单模拟1067 试密码 C++ 字符串处理1068 万绿丛中一点红 C++ 简单模拟1069 微博转发抽奖 C++ 中级模拟1070 结绳 C++ 贪心1071 小赌怡情 C++ 简单模拟1072 开学寄语 C++ 中级模拟+二分查找1073 多选题常见计分法 C++ 中级模拟+常用stl1074 宇宙无敌加法器 C++ 进制转换+字符串处理1075 链表元素分类 C++ 链表1076 Wifi密码 C++ 简单模拟1077 互评成绩计算 C++ 简单模拟1078 字符串压缩与解压 C++ 字符串处理1079 延迟的回文数 C++ 大整数运算1080 MOOC期终成绩 C++ 排序1081 检查密码 C++ 字符串处理1082 射击比赛 C++ 查找元素1083 是否存在相等的差 C++ 常用stl1084 外观数列 C++ 字符串处理1085 PAT单位排行 C++ 排序1086 就不告诉你 C++ 水题1087 有多少不同的值 C++ 水题1088 三人行 C++ 简单模拟1089 狼人杀-简单版 C++ 简单模拟1090 危险品装箱 C++ 常用stl1091 N-自守数 C++ 水题1092 最好吃的月饼 C++ 查找1093 字符串A+B C++ 散列1094 谷歌的招聘 C++ 素数1095 解码PAT准考证 C++ 排序————————————————版权声明：本文为CSDN博主「日沉云起」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/richenyunqi/article/details/84981369 https://blog.csdn.net/qq_40946921/article/details/81320389 Italink https://blog.csdn.net/weixin_42582136/article/details/100155268 [ME-&gt;CS] 字符串处理1002 写出这个数 (20 分)读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。 输入格式：每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 10100。 输出格式：在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。 输入样例：11234567890987654321123456789 输出样例：1yi san wu 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cmath&gt;int process(char a[])&#123; int result=0; for(int i=0;a[i]!='\0';++i) &#123; result+=a[i]-'0'; &#125; return result;&#125;int main()&#123; char num[110]; char arti[10][6]=&#123;"ling","yi","er","san","si","wu","liu","qi","ba","jiu"&#125;; scanf("%s",num); int res=process(num); int count=0; int temp=res; while(temp!=0) &#123; temp/=10; ++count; &#125; int pro; do &#123; pro=pow(10.0,count-1); printf("%s",arti[res/pro]); if(count&gt;1) printf(" "); else printf("\n"); res%=pro; --count; &#125;while(count&gt;0); return 0;&#125;emmmmm 就是先用字符数组存储，然后将每一位数加起来得到结果，最后处理的时候，可以利用整除法计算出数字的位数，然后再从高位到低位依次去整输出，（能用这种方法的原因是100位就算全是9加起来也就900，10的3次方而已，不会超限）注意末尾没有空格哦，其他的就没啥啦~ 123456789101112131415161718#include &lt;iostream&gt; (柳神代码)#include &lt;string&gt;using namespace std;int main() &#123;string s;cin &gt;&gt; s;int sum = 0;string str[10] = &#123;"ling", "yi", "er", "san", "si", "wu", "liu", "qi","ba", "jiu"&#125;;for (int i = 0; i &lt; s.length(); i++)sum += (s[i] - '0');string num = to_string(sum);for (int i = 0; i &lt; num.length(); i++) &#123;if (i != 0) cout &lt;&lt; " ";cout &lt;&lt; str[num[i] - '0'];&#125;return 0;&#125; 分析：⽤用string接收输⼊入，string的每⼀一位数字累加到sum⾥里里⾯面，再将sum转化为string类型的num，对num的每⼀一位输出对应中⽂文拼⾳音～]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>语法</tag>
        <tag>PAT</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++语言入门]]></title>
    <url>%2F2019%2F10%2F03%2FC%2B%2B%E6%88%91%E6%9D%A5%E4%BA%86%2F</url>
    <content type="text"><![CDATA[C++入门备注：cstdio是将stdio.h的内容用C++头文件的形式表示出来。stdio.h是C标准函数库中的头文件，即：standard buffered input&amp;output。提供基本的文字的输入输出流操作（包括屏幕和文件等）。由于C语言并没有提供专用于文字输入输出的关键字，所以该库是最普遍的C语言程序加载库。 cstdio 和 stdio.h是有差别的，并不是同样的文件。 stdio.h是以往的C和C++的头文件，cstdio是标准C++（STL），且cstdio中的函数都是定义在一个名称空间std里面的，如果要调用这个名字空间的函数，必须得加std::或者在文件中声明using namespace std。 [2] 1`#include&lt;cstdio&gt;` `using`` ``namespace`` std;``/*你也可以同时加上这个语句*/`]]></content>
      <categories>
        <category>语法练习</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>语法</tag>
        <tag>算法</tag>
        <tag>C++语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[明解C语言 实践篇]]></title>
    <url>%2F2019%2F10%2F03%2F%E6%98%8E%E8%A7%A3C%E8%AF%AD%E8%A8%80-%E4%B8%AD%E7%BA%A7%E7%AF%873%2F</url>
    <content type="text"><![CDATA[明解C语言-中级篇第1章 猜数游戏1-1 猜数判定 1.通过 if语句实现条件分支 123456789101112131415161718/* 猜数游戏（其一：测试版）*/#include &lt;stdio.h&gt;int main(void)&#123; int no; /* 读取的值 */ int ans = 7; /* 目标数字 */printf("请猜一个0~9的整数。\n\n");printf("是多少呢：");scanf("%d", &amp;no);if (no &gt; ans) printf("\a再小一点。\n");else if (no &lt; ans) printf("\a再大一点。\n");else printf("回答正确。\n");return 0;&#125; 转义字符 \n 换行 \a 警报 2.if 语句的嵌套 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if语法C 语言中 if 语句的语法： 1234if(boolean_expression)&#123; /* 如果布尔表达式为真将执行的语句 */&#125; C 语言中 if…else 语句的语法： 12345678if(boolean_expression)&#123; /* 如果布尔表达式为真将执行的语句 */&#125;else&#123; /* 如果布尔表达式为假将执行的语句 */&#125; if…else if…else 语句一个 if 语句后可跟一个可选的 else if…else 语句，这可用于测试多种条件。 当使用 if…else if…else 语句时，以下几点需要注意： 一个 if 后可跟零个或一个 else，else 必须在所有 else if 之后。 一个 if 后可跟零个或多个 else if，else if 必须在 else 之前。 一旦某个 else if 匹配成功，其他的 else if 或 else 将不会被测试。 C 语言中的 if…else if…else 语句的语法： 12345678910111213141516if(boolean_expression 1)&#123; /* 当布尔表达式 1 为真时执行 */&#125;else if( boolean_expression 2)&#123; /* 当布尔表达式 2 为真时执行 */&#125;else if( boolean_expression 3)&#123; /* 当布尔表达式 3 为真时执行 */&#125;else &#123; /* 当上面条件都不为真时执行 */&#125; 在 C 语言中，嵌套 if-else 语句是合法的，这意味着您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 C 语言中 嵌套 if 语句的语法： 12345678if( boolean_expression 1)&#123; /* 当布尔表达式 1 为真时执行 */ if(boolean_expression 2) &#123; /* 当布尔表达式 2 为真时执行 */ &#125;&#125; 1-1 重复猜到对为止重复输入 循环判断 do while 语句 先循环 后判断 注意 while 末尾带有; 1.通过do语句循环 C do…while 循环不像 for 和 while 循环，它们是在循环头部测试循环条件。在 C 语言中，do…while 循环是在循环的尾部检查它的条件。 do…while 循环与 while 循环类似，但是 do…while 循环会确保至少执行一次循环。 语法C 语言中 do…while 循环的语法： 12345do&#123; statement(s);&#125;while( condition ); 请注意，条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。 如果条件为真，控制流会跳转回上面的 do，然后重新执行循环中的 statement(s)。这个过程会不断重复，直到给定条件变为假为止。 实例12345678910111213141516#include &lt;stdio.h&gt; int main ()&#123; /* 局部变量定义 */ int a = 10; /* do 循环执行 */ do &#123; printf("a 的值： %d\n", a); a = a + 1; &#125;while( a &lt; 20 ); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 12345678910a 的值： 10a 的值： 11a 的值： 12a 的值： 13a 的值： 14a 的值： 15a 的值： 16a 的值： 17a 的值： 18a 的值： 19 2.通过while语句循环 while 循环只要给定的条件为真，C 语言中的 while 循环语句会重复执行一个目标语句。 语法C 语言中 while 循环的语法： 1234while(condition)&#123; statement(s);&#125; 在这里，statement(s) 可以是一个单独的语句，也可以是几个语句组成的代码块。 condition 可以是任意的表达式，当为任意非零值时都为 true。当条件为 true 时执行循环。 当条件为 false 时，退出循环，程序流将继续执行紧接着循环的下一条语句。 实例12345678910111213141516#include &lt;stdio.h&gt; int main ()&#123; /* 局部变量定义 */ int a = 10; /* while 循环执行 */ while( a &lt; 20 ) &#123; printf("a 的值： %d\n", a); a++; &#125; return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 12345678910a 的值： 10a 的值： 11a 的值： 12a 的值： 13a 的值： 14a 的值： 15a 的值： 16a 的值： 17a 的值： 18a 的值： 19 C break 语句C 语言中 break 语句有以下两种用法： 当 break 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。 它可用于终止 switch 语句中的一个 case。 如果您使用的是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。 语法C 语言中 break 语句的语法： 1break; 实例123456789101112131415161718192021#include &lt;stdio.h&gt; int main ()&#123; /* 局部变量定义 */ int a = 10; /* while 循环执行 */ while( a &lt; 20 ) &#123; printf("a 的值： %d\n", a); a++; if( a &gt; 15) &#123; /* 使用 break 语句终止循环 */ break; &#125; &#125; return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 123456a 的值： 10a 的值： 11a 的值： 12a 的值： 13a 的值： 14a 的值： 15 1-3 随机设定目标数字]]></content>
      <categories>
        <category>项目实践</category>
        <category>语法练习</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>语法</tag>
        <tag>C语言</tag>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10.2 test]]></title>
    <url>%2F2019%2F10%2F02%2Ftest%2F</url>
    <content type="text"><![CDATA[C语言实验题――相加和最大值时间限制: 1000MS 内存限制: 65536KByte 64位IO格式:%I64d &amp; %I64u 描述输入三个整数a,b,c。并进行两两相加，最后比较相加和的最大值。输入输入数据包含三个整数，用空格分开。输出输出两两相加后的最大值。样例输入**样例输出**[提交 1001 害死人不偿命的(3n+1)猜想 (15 分) 卡拉兹(Callatz)猜想： 对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… 我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？ 输入格式：每个测试输入包含 1 个测试用例，即给出正整数 n 的值。 输出格式：输出从 n 计算到 1 需要的步数。 输入样例：13 输出样例：15 问题 A: 例题5-1-1 连续自然数求和时间限制: 1 Sec 内存限制: 12 MB提交: 2221 解决: 1832[提交][状态][讨论版][命题人:外部导入] 题目描述求1+2+3+…+100，即求 要求用while语句实现 输入无 输出要求的和，末尾输出换行。 样例输入1无 样例输出15050 [提交][状态] 描述 输入三个整数a,b,c。并进行两两相加，最后比较相加和的最大值。 输入 输入数据包含三个整数，用空格分开。 输出 输出两两相加后的最大值。 样例输入 样例输出 1234567891011121314151617181920212223## **C语言实验题――相加和最大值****描述**输入三个整数a,b,c。并进行两两相加，最后比较相加和的最大值。**输入**输入数据包含三个整数，用空格分开。**输出**输出两两相加后的最大值。**样例输入****样例输出**5]]></content>
      <categories>
        <category>CS基础</category>
      </categories>
      <tags>
        <tag>计组</tag>
        <tag>专业课</tag>
        <tag>笔记</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理]]></title>
    <url>%2F2019%2F10%2F02%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[计算机组成原理预备知识进制知识 数电逻辑 计算机中阶符、阶码、数符、尾数的意思一个浮点数a由两个数m和e来表示：a = m × b^e。在任意一个这样的系统中，我们选择一个基数b（记数系统的基）和精度p（即使用多少位来存储）。m（即尾数）是形如±d.ddd…ddd的p位数（每一位是一个介于0到b-1之间的整数，包括0和b-1)。如果m的第一位是非0整数,m称作规格化的。有一些描述使用一个单独的符号位(s 代表+或者-）来表示正负，这样m必须是正的。e是指数。 结构由此可以看出，在计算机中表示一个浮点数，其结构如下：尾数部分（定点小数） 阶码部分（定点整数） 一个十进制数可写成一个纯小数乘上10的若干次方，相似的，一个二进制可写成一个纯小数乘上2的若干次方。例如，11.01=22×0.1101；一般地,任一个二进制N，可表示为N=2j×S； 其中J为二进制数，叫阶码；J如果有正负号的话，正负号就叫阶符；S为纯小数，叫做尾数；数符，指的是N整个数的符号。 浮点数能表示的范围由阶码的位数决定，精确度有尾数的位数决定————————————————版权声明：本文为CSDN博主「猴儿2333」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/littlecase233/article/details/82959410 在尾数用补码表示时，规格化浮点数应满足尾数最高数位与符号位不同，如相同就是不满足规格化。尾数用双符号位补码表示，经过加/减运算之后，可能出现以下六种情况，即① 00.1 x x … x② 11.0 x x … x③ 00.0 x x … x④ 11.1 x x … x⑤ 01.x x x … x⑥ 10.x x x … x 第①、②种情况，符合规格化数的定义，已是规格化数。 第③、④种情况不是规格化数，需要使尾数左移以实现规格化，这个过程称为左规。尾浮点数运算的的规格化浮点数运算的的规格化浮点数运算的的规格化数每左移一位，阶码相应减 1，直至成为规格化数为止。左规可以进行多次。 第⑤、⑥种情况在定点加减运算中称为溢出，但在浮点加减运算中，只表明此时尾数的 绝对值大于 1，而并非真正的溢出。这种情况应将尾数右移以实现规格化。这个过程称为右 规。尾数每右移一位，阶码相应加 1。右规最多只有一次。 总结：左规处理，及时数往小数点左边走，阶码-1，右规反之。 https://blog.csdn.net/qq546770908/article/details/45486397 小数的二进制表示，阶码知识点 加 题目 加 排版 加 图片 加 个人思想第1章 计算机系统概率1.1 计算机的分类 1.2 计算机的发展简史已知补码如何求原码（真值）~1.当补码最高位为0时因为最高位为0，即该数是正数，正数的原码、反码、补码都是一样的。 所以该补码即是原码。 例如：【X】补=01111111求真值。 解：因为最高位为0，所以【X】原=【X】补=01111111=127. 2.当补码最高位为1时因为最高位是1，所以该数为负数。负数的补码=反码+1 补码 的补码 即为该补码的原码（真值）。]]></content>
      <categories>
        <category>CS基础</category>
      </categories>
      <tags>
        <tag>计组</tag>
        <tag>专业课</tag>
        <tag>笔记</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.10.1 C语言入门及进阶 （国庆天天乐）]]></title>
    <url>%2F2019%2F10%2F01%2FC%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%8F%8A%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[C语言入门及进阶 \t 制表符 与 空格的关系 https://www.cnblogs.com/guokai/p/3641953.html tab 如何 在 C 输出 \ % %% \ \ 如何在 C使用 百分数 % double n,x; n=0.01*x; 2.各种类型输入输出 123456789101112131415特别注意 A-Z区间的表示 以及 字符的 ''#include &lt;stdio.h&gt;int main()&#123; char n; scanf("%c",&amp;n); if(n&gt;='A'&amp;&amp;n&lt;='Z')&#123; printf("%c",n+32);&#125; else printf("%c",n); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;int main()&#123; char a,b,c,d,e; scanf("%c",&amp;a); scanf("%c",&amp;b); scanf("%c",&amp;c); scanf("%c",&amp;d); scanf("%c",&amp;e); printf("password is %c%c%c%c%c",a+4,b+4,c+4,d+4,e+4); return 0;&#125;方法 #include &lt;stdio.h&gt;int main()&#123; char a,b,c,d,e; scanf("%c%c%c%c%c",&amp;a,&amp;b,&amp;c,&amp;d,&amp;e); printf("password is %c%c%c%c%c",a+4,b+4,c+4,d+4,e+4); return 0;&#125;方法三#include &lt;stdio.h&gt;int main()&#123; char a,b,c,d,e; a=getchar(); b=getchar(); c=getchar(); d=getchar(); e=getchar(); printf("password is "); putchar(a+4); putchar(b+4); putchar(c+4); putchar(d+4); putchar(e+4); return 0;&#125; 这种 不行 会报错 1234567891011121314#include&lt;stdio.h&gt;//实现摄氏温度和华氏温度的转化函数float f_c(float F)&#123; return 5*(F-32)/9;&#125;int main()&#123; float f,c; scanf("%f",&amp;f); c=f_c(f); printf("%.2f",c); return 0;&#125; 3.简单运算 123456789#include &lt;stdio.h&gt;int main()&#123; int a,b,c; scanf("%d%d",&amp;a,&amp;b); c=(a/10)*1000+(a%10)*10+(b/10)*100+(b%10); printf("The result is: %d",c); return 0;&#125; 4.加点难度的运算 123456789#include &lt;stdio.h&gt;int main()&#123; int n,x; scanf("%d",&amp;n); x=(n%10)*100+((n%100)/10)*10+(n/100); printf("%d",x); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;int main()&#123; int a; int b; scanf("%d %d", &amp;a, &amp;b); printf("%d", b/a+1); return 0;&#125;化繁为简 考虑简单的超时的程序？ ＞的话 反过来就要考虑 小于等于#include &lt;stdio.h&gt;int main()&#123; int a,b,m=1,z; scanf("%d%d",&amp;a,&amp;b); while(z&lt;=b) &#123; m++; z=a*m; &#125; printf("%d",m); return 0;&#125;这里涉及了 C语言运行程序的计算 调试 https://www.cnblogs.com/Emcikem/p/11518388.html#include&lt;stdio.h&gt;#include&lt;time.h&gt; //用到clock()函数int main() &#123; int begintime,endtime; int i = 0; int a[1002]; begintime=clock(); //计时开始 /* 代码块 */ endtime = clock(); //计时结束 printf("\n\nRunning Time：%dms\n", endtime-begintime); return 0;&#125; 1234567891011#include &lt;stdio.h&gt;int main()&#123; int x,y,n,m; scanf("%d%d",&amp;n,&amp;m); y=(m-2*n)/2; x=n-y; printf("%d %d",x,y); return 0;&#125;数学果然是个好东西 5.简单选择结构 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; int a; scanf("%d",&amp;a); if(a%3==0&amp;&amp;a%5==0) &#123; printf("Yes"); &#125; else &#123; printf("No"); &#125; return 0;&#125; 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int main()&#123; int a,b,c,t; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); if(a&gt;b) &#123; t=a; a=b; b=t; &#125; if(a&gt;c) &#123; t=a; a=c; c=t; &#125; if(b&gt;c) &#123; t=b; b=c; c=t; &#125; printf("%d",b); return 0;&#125; 三目运算符三数比较123456789#include &lt;stdio.h&gt;int main()&#123; int a,b,c,max; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); max=(a&gt;b)?((a&gt;c)?a:c):((b&gt;c)?b:c); printf("max=%d",max); return 0;&#125; 二数比较123456789#include &lt;stdio.h&gt;int main()&#123; int a,b,max; scanf("%d%d",&amp;a,&amp;b); max=a&gt;b?a:b; printf("max=%d",max); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;int main()&#123; int a,b,c,x,y,z,max; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); x=a+b; y=a+c; z=b+c; max=(x&gt;y)?((x&gt;z)?x:z):((y&gt;z)?y:z); printf("%d",max); return 0;&#125;#include&lt;stdio.h&gt;int main()&#123;int a,b,c;int x,y,z; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); x=a+b; y=a+c; z=b+c; if(x&gt;=y&amp;&amp;x&gt;=z) &#123; printf("%d",x); &#125;else&#123; if(y&gt;z&amp;&amp;y&gt;x) &#123; printf("%d",y); &#125;else&#123; printf("%d",z); &#125; &#125;&#125; 1234567891011#include &lt;stdio.h&gt;int main()&#123; int a,b,c,max,min,n; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); max=(a&gt;b)?((a&gt;c)?a:c):((b&gt;c)?b:c); min=(a&lt;b)?((a&lt;c)?a:c):((b&lt;c)?b:c); n=max-min; printf("%d",n); return 0;&#125; 123456789101112131415#include&lt;stdio.h&gt;int main()&#123;C int a,b,c,d; scanf("%d.%d.%d.%d",&amp;a,&amp;b,&amp;c,&amp;d); if(0&lt;=a&amp;&amp;a&lt;=255&amp;&amp; 0&lt;=b&amp;&amp;b&lt;=255&amp;&amp; 0&lt;=c&amp;&amp;c&lt;=255&amp;&amp; 0&lt;=d&amp;&amp;d&lt;=255) printf("YES"); else printf("NO"); return 0; &#125; 6.加强选择结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;int main()&#123; int month,year; scanf("%d\\%d",&amp;year,&amp;month); if(month==1||month==3||month==5||month==7||month==8||month==10||month==12) printf("31"); else if(month==4||month==6||month==9||month==11) printf("30"); if(month==2) &#123; if(year%4==0&amp;&amp;year%100!=0||year%400==0) printf("29"); else printf("28"); &#125; return 0;&#125;#include&lt;stdio.h&gt;int main()&#123; int year,month,day; scanf("%d\\%d",&amp;year,&amp;month); switch(month) &#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12:day=31;break; case 4: case 6: case 9: case 11:day=30;break; &#125; if(month==2) &#123; if((year%4==0&amp;&amp;year%100!=0)||year%400==0) day=29; else day=28; &#125; printf("%d",day); return 0;&#125; 123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; float a,b,c; float x1,x2,d; scanf("%f %f %f",&amp;a,&amp;b,&amp;c); if(a!=0)&#123; d=sqrt((b*b)-(4.0*a*c)); x1=((-b+d)/(2.0*a)); x2=((-b-d)/(2.0*a)); if(x1&gt;=x2) &#123; printf("%.2f %.2f",x1,x2); &#125; else printf("%.2f %.2f",x2,x1);&#125; else printf("not root!"); return 0;&#125; 强调 实数的定义 数学知识的补充 课外知识的背景 还有 学好英语！！！！！上面挖个坑 你把函数 指针 学熟 再来补 12345678910111213141516171819202122#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() &#123; double a,b,c,x1,x2,m,n; scanf("%lf%lf%lf",&amp;a,&amp;b,&amp;c); if(a==0)printf("%.2f %.2f\n",-c/b,-c/b); else if(b*b-4*a*c&lt;0) &#123; m=-b/(2*a); n=sqrt(4*a*c-b*b); if(a&gt;0)printf("%.2f+%.2fi %.2f-%.2fi\n", m,n/(2*a),m,n/(2*a) ); else printf("%.2f+%.2fi %.2f%.2fi\n", m,-n/(2*a),m,n/(2*a)); &#125; else &#123; x1=(-b+sqrt(b*b-4*a*c))/(2*a); x2=(-b-sqrt(b*b-4*a*c))/(2*a); if(x1&gt;x2)printf("%.2f %.2f",x1,x2); else printf("%.2f %.2f",x2,x1); &#125; return 0; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt; int main() &#123; int x,y,z; scanf("%d,%d,%d",&amp;x,&amp;y,&amp;z); if(x&gt;y&amp;&amp;x&gt;z) &#123; if(y&gt;z) printf("%d %d %d",z,y,x); else printf("%d %d %d",y,z,x); &#125; else if(y&gt;x&amp;&amp;y&gt;z) &#123; if(x&gt;z) printf("%d %d %d",z,x,y); else printf("%d %d %d",x,z,y);&#125; else if(z&gt;y&amp;&amp;z&gt;x)&#123; if(x&gt;y) printf("%d %d %d",y,x,z); else printf("%d %d %d",x,y,z);&#125;return 0; &#125; #include&lt;stdio.h&gt;int main()&#123; int a,b,c,max,min,mid; scanf("%d,%d,%d",&amp;a,&amp;b,&amp;c); max=(a&gt;b)?((a&gt;c)?a:c):((b&gt;c)?b:c); min=(a&lt;b)?((a&lt;c)?a:c):((b&lt;c)?b:c); mid=a+b+c-max-min; printf("%d %d %d",min,mid,max); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;stdio.h&gt;typedef struct Time&#123; int h,m,s;&#125;Time;/* 描述时间的结构体 *//* 输入时间函数 */void ReadTime(Time *time)&#123; scanf("%d:%d:%d",&amp;time-&gt;h,&amp;time-&gt;m,&amp;time-&gt;s);&#125;/* 输出时间函数 */void PrintTime(Time *time)&#123; printf("%d:",time-&gt;h); if(time-&gt;m&lt;10) printf("0"); printf("%d:",time-&gt;m); if(time-&gt;s&lt;10) printf("0"); printf("%d",time-&gt;s); &#125;//计算两个时间只差 void TimeSub(Time *time1,Time *time2,Time *time)&#123; long t1,t2,t; t1=time1-&gt;h * 3600 + time1-&gt;m *60 + time1-&gt;s; t2=time2-&gt;h * 3600 + time2-&gt;m *60 + time2-&gt;s; t=t1-t2;//将时间转化为秒 if(t&lt;0) t=t*(-1); //将秒转化为时间 time-&gt;h= t/3600; time-&gt;m= (t-time-&gt;h*3600)/60; time-&gt;s= t%60; &#125;int main()&#123; Time time1,time2,time; ReadTime(&amp;time1);//读时间 ReadTime(&amp;time2);//读第一个时间 TimeSub(&amp;time1,&amp;time2,&amp;time);//计算减法 PrintTime(&amp;time);//返回一个时间 return 0; &#125;#include&lt;stdio.h&gt;int main()&#123; int h1, m1, s1; int h2, m2, s2; int a, b, c; scanf("%d:%d:%d", &amp;h1, &amp;m1, &amp;s1); scanf("%d:%d:%d", &amp;h2, &amp;m2, &amp;s2); if (h1 * 3600 + m1 * 60 + s1 &lt; h2 * 3600 + m2 * 60 + s2) &#123; a = h2 - h1, b = m2 - m1, c = s2 - s1; if (c &lt; 0) &#123; c = 60 + c; b--; &#125; if (b &lt; 0) &#123; b = b + 60; a--; &#125; &#125; else &#123; a = h1 - h2, b = m1 - m2, c = s1 - s2; if (c &lt; 0) &#123; c = 60 + c; b--; &#125; if (b &lt; 0) &#123; b = b + 60; a--; &#125; &#125; printf("%d:%02d:%02d", a, b, c);&#125;#include&lt;stdio.h&gt;int main()&#123; int h1, h2, m1, m2, s1, s2, t1, t2, del; t1 = t2 = 0; scanf("%d:%d:%d",&amp;h1, &amp;m1, &amp;s1); scanf("%d:%d:%d",&amp;h2, &amp;m2, &amp;s2); t1 = h1 * 3600 + m1 * 60 + s1; t2 = h2 * 3600 + m2 * 60 + s2; if(t1 &gt; t2) &#123; del = t1 - t2; &#125; else &#123; del = t2 - t1; &#125; int a, b, c; a = del / 3600; b = del / 60 % 60; c = del % 60; printf("%02d:%02d:%02d\n",a, b, c); return 0;&#125; 7.简单一重循环 123456789#include&lt;stdio.h&gt;int main()&#123; int n,i; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) printf("%d\n",i); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;int main()&#123; float sum=0.0; int a=1,i; for (i=1;i&lt;=100;i++)&#123; sum+=(1.0*a)/i; a=-a; &#125; printf("%f",sum); return 0;&#125;#include &lt;stdio.h&gt;int main(void)&#123; int i = 1; float sum = 0; while(i &lt;= 100) &#123; if(i % 2 == 0) &#123; sum -=1/(i++*1.0); &#125;else &#123; sum +=1/(i++*1.0); &#125; &#125; printf("%f\n",sum);&#125; ​ 1.0 的重要性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;int main(void)&#123; int num=0,i=0,a=0; int str[1000]; scanf("%d",&amp;num); for(i=0;i&lt;num;i++) &#123; scanf("%d",&amp;a); str[i]=a; &#125; for(i=0;i&lt;num;i++) &#123; printf("%c",str[i]); &#125; return 0;&#125;#include &lt;stdio.h&gt;int main()&#123; int n; scanf("%d",&amp;n); int i,a; for( i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a); printf("%c",a);&#125;&#125; #include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; int n,i; char s[100]; int len=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; int a; scanf("%d",&amp;a); if(a&gt;=0&amp;&amp;a&lt;=256) s[len++]=a; //ASCll范围[0,256] &#125; s[len]='\0'; printf("%s",s); return 0;&#125;#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; char c[1001]; int x[1001]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; scanf("%d",&amp;x[i]); c[i]=x[i]; &#125; for(int i=0;i&lt;n;i++) printf("%c",c[i]);&#125; https://www.cnblogs.com/kimsimple/p/6874988.html #include&lt;bits/stdc++.h&gt;包含了目前c++所包含的所有头文件 12345678910111213141516#include &lt;stdio.h&gt;int main()&#123;float a;int n,i;float sum=0,average;scanf("%d",&amp;n);for(i=0;i&lt;n;i++)&#123;scanf("%f",&amp;a);sum=sum+a;&#125;average=sum/n;printf("%.2f",average);return 0;&#125; 12345678910111213#include&lt;stdio.h&gt;int main()&#123; int t,a,b,sum; scanf("%d",&amp;t); while(t--) &#123; scanf("%d%d",&amp;a,&amp;b); sum=(a%100+b%100)%100;//实验证明若用sun=(a+b)%100，在hdoj上提交会WA printf("%d\n",sum); &#125; return 0;&#125; 关于while(n–)知识点的补充下面这段代码我们都很熟悉 #include &lt;stdio.h&gt;int main(){ int n=5; while(n) { n=n-1; } printf(“%d\n”,n); return 0;}它的输出结果为0.再看下面这一段代码： #include &lt;stdio.h&gt;int main(){ int n=5; while(n–) { ; } printf(“%d\n”,n); return 0;}它的输出结果却是-1.很多人都认为这两段代码是等价的，我之前也误认为它们等价，但是实验证明这不是等价的。 第二段代码中，while(n–)，当n=0时，并没有马上跳过循环条件和循环体，而是将循环条件执行完再跳过循环体。 原因：n–是一个整体，从编译器gcc角度看，先将n赋值给一个临时变量，然后自身减去1，返回的不是n而是临时变量。此时临时变量0，n为-1。故n–操作是一个整体，必须完整的执行完，不是割裂看的。之前，我误认为while中判断n为0时就直接结束。 12345678910111213141516#include&lt;stdio.h&gt;int main()&#123; int n,a,b,i; float sum =0; scanf("%d",&amp;n); a = 1; b = 2; for(i =0; i&lt;n;i++) &#123; sum = sum + 1.0/a - 1.0/b; a = a+2; b = b+2; &#125; printf("%0.2f\n",sum);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;int main()&#123; int i,n,fm=0; double sum=0; scanf("%d",&amp;n); for ( i=0;i&lt;n;i++ ) //总共n次循环，加n项&#123; fm+=(i+1); //分母每次累加当前项号：0+1,1+2,3+3,... sum+=(double)1/fm; //累加当前项&#125; printf("%.2f\n",sum);&#125;#include&lt;stdio.h&gt;int main()&#123; int i,n; double s=0,m=0; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)&#123; m+=i; s+=1.0/m;&#125; printf("%.2lf",s);&#125;#include&lt;stdio.h&gt;int main()&#123; int n,i; float sum=0,s=0; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) &#123; sum=sum+i; s=s+(1.0/sum); &#125; printf("%.2f",s); return 0;&#125; 论 sum=0的重要性 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; double x1,x0,d; x1=0.0; x1=cos(x0); scanf("%lf",&amp;d); while(fabs(x0-x1)&gt;d)&#123; x0=x1; x1=cos(x0);&#125; printf("%.2f\n",x1); return 0;&#125; 迭代迭代法是数值计算中一类典型方法，应用于方程求根，方程组求解，矩阵求特征值等方面。其基本思想是逐次逼近，先取一个粗糙的近似值，然后用同一个递推公式，反复校正此初值，直至达到预定精度要求为止。 从概念上讲，递归就是指程序调用自身的编程思想，即一个函数调用本身；迭代是利用已知的变量值，根据递推公式不断演进得到变量新值得编程思想。 从直观上讲，递归是将大问题化为相同结构的小问题，从待求解的问题出发，一直分解到已经已知答案的最小问题为止，然后再逐级返回，从而得到大问题的解（一个非常形象的例子就是分类回归树 classification and regression tree，从root出发，先将root分解为另一个(root,sub-tree)，就这样一直分解，直到遇到leafs后逐层返回）；而迭代则是从已知值出发，通过递推式，不断更新变量新值，一直到能够解决要求的问题为止。 递归实际上不断地深层调用函数，直到函数有返回才会逐层的返回，因此，递归涉及到运行时的堆栈开销（参数必须压入堆栈保存，直到该层函数调用返回为止），所以有可能导致堆栈溢出的错误；但是递归编程所体现的思想正是人们追求简洁、将问题交给计算机，以及将大问题分解为相同小问题从而解决大问题的动机。 迭代大部分时候需要人为的对问题进行剖析，将问题转变为一次次的迭代来逼近答案。迭代不像递归一样对堆栈有一定的要求，另外一旦问题剖析完毕，就可以很容易的通过循环加以实现。迭代的效率高，但却不太容易理解，当遇到数据结构的设计时，比如图‘表、二叉树、网格等问题时，使用就比较困难，而是用递归就能省掉人工思考解法的过程，只需要不断的将问题分解直到返回就可以了。 总之，递归算法从思想上更加贴近人们处理问题的思路，而且所处的思想层级算是高层（神），而迭代则更加偏向于底层（人），所以从执行效率上来讲，底层(迭代)往往比高层(递归)来的高，但高层(递归)却能提供更加抽象的服务，更加的简洁。 从个人来讲，我非常认同“迭代是人，递归是神”！ 编程中，循环、迭代、遍历和递归之间的区别循环(loop) - 最基础的概念, 所有重复的行为递归(recursion) - 在函数内调用自身, 将复杂情况逐步转化成基本情况(数学)迭代(iterate) - 在多次循环中逐步接近结果(编程)迭代(iterate) - 按顺序访问线性结构中的每一项遍历(traversal) - 按规则访问非线性结构中的每一项————————————————版权声明：本文为CSDN博主「Never-say-Never」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/mad1989/article/details/8933078 当型循环和直到型循环当型循环：开始循环判断循环条件，成立执行循环体判断循环条件，成立执行循环体…判断循环条件，这一次条件不成立不执行循环体，直接继续往下 直到型循环：开始循环执行循环体判断循环条件，成立执行循环体…判断循环条件，这一次条件不成立不执行循环体，直接继续往下 “当型”while(i&lt;n){…..}则说明当满足条件i&lt;n时执行{ }中代码； “直到型”do{} while(i&lt;n)则说明先执行{ }中代码，再判断是否是i&lt;n; 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;int main()&#123; int n,max,i,j; scanf("%d",&amp;n); if(n&gt;=1&amp;&amp;n&lt;=10) &#123; for(i=0;i&lt;n;i++) &#123; scanf("%d",&amp;j); if(i==0) &#123; max=j; &#125; else &#123; max =(max&gt;j)?max:j; &#125; &#125; &#125; printf("%d",max); return 0;&#125;#include &lt;stdio.h&gt;int main()&#123; int i,n,max,a[20]; scanf("%d",&amp;n); scanf("%d",&amp;a[0]); max=a[0]; for(i=1;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); if(max&lt;a[i]) max=a[i];&#125; printf("%d",max); return 0;&#125; 比较 输出 最大最小值 8.加强一重循环https://blog.csdn.net/S1259364843/article/details/92420371 C语言求最小公倍数和最大公约数三种算法(经典) 12345678910#include&lt;stdio.h&gt; int main() /* 辗转相除法求最大公约数 */ &#123; int m, n, a, b, t, c; scanf("%d %d", &amp;a,&amp;b); m=a; n=b; while(b!=0) /* 余数不为0，继续相除，直到余数为0 */ &#123; c=a%b; a=b; b=c;&#125; printf("%d %d\n",m*n/a,a);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;int check(int num);int main()&#123; int i; int count; int num; count=0; scanf("%d", &amp;num); for(i=1; i&lt;=num; i++) &#123; if(i%3==0) &#123; count++; &#125; else if(check(i)) &#123; count++; &#125; &#125; printf("%d", count);&#125;int check(int num)&#123; int flag=0; while(num) &#123; if(num%10==3) &#123; flag=1; &#125; num/=10; &#125; return flag;&#125; 1234567891011121314151617#include&lt;stdio.h&gt;int main()&#123; double n=2,m=1,N,t,sum=0.00; scanf("%Lf",&amp;N);while(N)&#123; sum=sum+n/m; t=m; m=n; n=n+t; N--;&#125; printf("%.6f\n",sum);return 0;&#125; 1234567891011121314#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() &#123; int n; double sum=0,i,t=1; scanf("%d",&amp;n); for(i=1;i&lt;=4*n-1;i=i+2) &#123; sum=sum+t/i; t=-t; &#125; printf("%.5f",4*sum); return 0; &#125; 素数：除了1和它自己之外，不能被其他数整除的数。 以下用三种方法解答： https://blog.csdn.net/yuemeicheng/article/details/81185154 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int main()&#123; int i,j; int count=0; int a[100]; //求素数 for(i=100;i&lt;=200;i++) &#123; for(j=2;j&lt;i;j++) &#123; if(i%j==0) //如果i/j没有余数就跳出循环 &#123; break; &#125; &#125; if(i==j) //判断是不是跳出循环的数， &#123; a[count++]=i; //把素数存入数组 &#125; &#125; printf("%d\n",count); for (i=0;i&lt;count;i++) &#123; printf("%d",a[i] ); //输出 if(i!=count-1) &#123; printf(" "); &#125; &#125; return 0;&#125; 1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123; double x, sum, t, item; int n, i; while (scanf("%lf %d", &amp;x, &amp;n)==2) &#123; t = x*x; item = 1.0; sum = 1.0; for (i=1; i&lt;=n; i++) &#123; item *= -t; item /= (i*2-1)*(i*2); sum += item; &#125; printf("%.4lf\n", sum); &#125; return 0;&#125; 123456789101112#include&lt;stdio.h&gt;int main()&#123; int sum=0,n,m,i; scanf("%d %d",&amp;n,&amp;m); for(i=n;i&lt;=m;i++) &#123; sum+=i*i; &#125; printf("%d\n",sum); return 0;&#125; 9.多组数据格式]]></content>
      <categories>
        <category>语法练习</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>语法</tag>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.9.28 初试茅庐 语法与软件测试 练习]]></title>
    <url>%2F2019%2F09%2F27%2F%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[语法练习题目描述输入三个整数，比较三个数的大小。输出“max=”，之后输出最大的值。 输入三个整数，用逗号分隔。 输出请输出读入的三个整数的最大值，并在最大值之前输出“max=”。请注意不需要输出引号，行尾输出换行。 样例输入18,5,20 样例输出1max=20 题解12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int a,b,c; scanf("%d,%d,%d",&amp;a,&amp;b,&amp;c); if(a&gt;b) &#123; if (a&gt;c) printf("max=%d",a); else printf("max=%d",c); &#125; else printf("max=%d",b); return 0; &#125; 123456789#include &lt;stdio.h&gt;int main()&#123; int a,b,c,max; scanf("%d,%d,%d",&amp;a,&amp;b,&amp;c); max=((a&gt;b)?a:b)&gt;c?max:c; printf("max=%d",max); return 0; &#125; 递归123456789101112131415`#include &lt;stdio.h&gt;``int F(int n)``&#123;` `if(n==0)` `return 1;` `else` `return F(n-1)*n;` `&#125;``int main()``&#123;` `int n;` `scanf("%d",&amp;n);` `printf("%d\n",F(n));` `return 0;` `&#125;` 题目描述输入一个2000至2500年间（包含2000年和2500年）的任意年份，判断是否是闰年。 输入输入一个整数year，表示年份。输入保证2000≤year≤2500。 输出如果输入的年份是闰年，请输出“leap year”，否则请输出“not leap year”。请注意不需要输出引号，行尾输出换行。 样例输入12100 样例输出1not leap year 12345678910111213141516#include &lt;stdio.h&gt; int main()&#123; int y; printf("请输入一个2000至2500年间的任意年份："); scanf("%d",&amp;y); if(y%4==0&amp;&amp;y%100!=0||y%400==0) &#123; printf("leap year"); &#125; else &#123; printf("not leap year"); &#125; return 0;&#125; 题目描述计算 输入无 输出输出题目描述中表达式的值，使用C语言默认舍入方式保留8位小数。请注意行尾输出换行。 样例输入1无 样例输出10.68817218 12345678910111213#include &lt;stdio.h&gt; int main()&#123; int sign=1; double j,sum=0; for(j=1;j&lt;=100;j++)&#123; sum+=sign*(1/j); sign=-sign;&#125;printf("%.8f",sum);return 0;&#125;]]></content>
      <categories>
        <category>语法练习</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>语法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190922日总结]]></title>
    <url>%2F2019%2F09%2F22%2F20190922%E6%97%A5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[妈的 花了一天时间 就整出这个傻屌东西醉了 醉了编程 太难了智力不够劝退搬砖大家好 我是憨憨憨是憨憨的憨2019.9.22 成果纪念 接下来的日子 抽时间 完善网站功能学习makedownC语言基础语法+数据结构+算法+项目+实践开始 NEW PLAN倒计时！！！！！！读杂书 进阶]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
